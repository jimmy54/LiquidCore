/*
 * Copyright (c) 2018 Eric Lange
 *
 * Distributed under the MIT License.  See LICENSE.md at
 * https://github.com/LiquidPlayer/LiquidCore for terms and conditions.
 */

/* In JavaScriptCore, a typed array that is constructed with an ArrayBuffer with non-integer
 * offset and/or length arguments will be treated as a zero-length array.  V8 takes the size
 * of the underlying ArrayBuffer.  We simulate that here.
 *
 * Also, in order for the V8 API to work properly with ArrayBuffer, the underlying ArrayBuffer must
 * be created by V82JSC and not JavaScriptCore directly.  There are 5 constructors to
 * typed arrays, e.g.:
 *
 * new Int8Array(); // new in ES2017
 * new Int8Array(length);
 * new Int8Array(typedArray);
 * new Int8Array(object);
 * new Int8Array(buffer [, byteOffset [, length]]);
 *
 * Only the last constructor will work with the V8 API since the ArrayBuffer is implicitly
 * generated by JSC in the others.  In this polyfill, we make those ArrayBuffer creations explicit.  The
 * ArrayBuffer constructor is proxied in V82JSC, so this will ensure they are compliant.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(factory());
}(this, (function () { 'use strict';
  const handler = {
    construct(target, args, newTarget) {
      if (args.length < 1 || args[0] === undefined) {
        // new Int8Array();
        return Reflect.construct(
          target,
          [new ArrayBuffer()],
          newTarget
        );
      } else if (typeof args[0] === 'object' && args[0] instanceof ArrayBuffer) {
        // new Int8Array(buffer [, byteOffset [, length]]);
        if (args.length >= 3 && (args[1] === undefined || args[1] === null) &&
             (args[2] === undefined || args[2] === null)) {
          // new Int8Array(buffer, null, null)
          args = [args[0], 0, args[0].byteLength];
        }
        return Reflect.construct(
          target,
          args,
          newTarget
        );
      } else if (typeof args[0] === 'object') {
        // new Int8Array(object);
        // new Int8Array(typedArray);
        let copy = Reflect.construct(target, args);
        let buffer = new ArrayBuffer(copy.buffer.byteLength)
        let typedarray =  Reflect.construct(
          target,
          [buffer],
          newTarget
        );
        typedarray.set(copy);
        return typedarray;
      } else if (typeof args[0] === 'number') {
        // new Int8Array(length);
        return Reflect.construct(
          target,
          [new ArrayBuffer(args[0] * Reflect.get(target, 'BYTES_PER_ELEMENT'))],
          newTarget
        );
      } else {
        // Invalid constructor, likely new Int8Array(string | boolean);
        return Reflect.construct(
          target,
          [new ArrayBuffer()],
          newTarget
        );
      }
    },

    get(target, prop, receiver) {
      if (prop === 'from') {
        return function from() {
          let arr = target.from(...arguments)
          let buffer = new ArrayBuffer(arr.buffer.byteLength)
          let typedarray =  Reflect.construct(
            target,
            [buffer]
          );
          typedarray.set(arr);
          return typedarray;
        }
      } else if (prop === 'of') {
        return function from() {
          let arr = target.of(...arguments)
          let buffer = new ArrayBuffer(arr.buffer.byteLength)
          let typedarray =  Reflect.construct(
            target,
            [buffer]
          );
          typedarray.set(arr);
          return typedarray;
        }
      } else return Reflect.get(target, prop, receiver)
    }
  }

  Uint8Array = new Proxy(Uint8Array, handler)
  Uint16Array = new Proxy(Uint16Array,handler)
  Uint32Array = new Proxy(Uint32Array,handler)
  Uint8ClampedArray = new Proxy(Uint8ClampedArray,handler)
  Int8Array = new Proxy(Int8Array,handler)
  Int16Array = new Proxy(Int16Array,handler)
  Int32Array = new Proxy(Int32Array,handler)
  Float32Array = new Proxy(Float32Array,handler)
  Float64Array = new Proxy(Float64Array,handler)
})));